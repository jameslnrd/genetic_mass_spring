import java.util.Arrays;
import ddf.minim.UGen;

import miPhysics.*;

int dimX = 25;
int dimY = 25;

float m = 1.0;
float k = 0.2;
float z = 0.0001;
float dist = 25;
float z_tension = 25;
float fric = 0.00001;
float grav = 0.;

int listeningPoint = 15;
int excitationPoint = 10;

int maxListeningPt;

public class PhyUGen extends UGen
{
  
  private String listeningPoint;

  private float oneOverSampleRate;
  public int center_x;
  public int center_y;
  public phyGenome genome;

  PhysicalModel mdl;

  // strat with ony one constructor for the function.
  public PhyUGen(int sampleRate, phyGenome genome, double offsX, double offsY)
  {
    super();
    // TODO use findCenter
    this.center_x = (int)offsX;
    this.center_y = (int)offsY;
    this.genome = genome;
    
    this.mdl = new PhysicalModel(sampleRate, displayRate);
    mdl.setGravity(0.000);
    mdl.setFriction(fric);

    generateMesh2(mdl, offsX, offsY, genome, "osc", "spring");

    listeningPoint = "mass_5";

    this.mdl.init();
  }

  /**
   * This routine will be called any time the sample rate changes.
   */
  protected void sampleRateChanged()
  {
    oneOverSampleRate = 1 / sampleRate();
    this.mdl.setSimRate((int)sampleRate());
  }

  @Override
  protected void uGenerate(float[] channels)
  {
    float sample;
    synchronized(lock) {
      this.mdl.computeStep();
  
      // calculate the sample value
      if(this.mdl.matExists(listeningPoint)) {
        sample =(float)(this.mdl.getMatPosition(listeningPoint).z * 0.01);
      } else {
        sample = 0;
      }
      Arrays.fill(channels, sample);
    }
  }
  
  void drawLine(Vect3D pos1, Vect3D pos2) {
    line((float)pos1.x, (float)pos1.y, zZoom *(float)pos1.z, (float)pos2.x, (float)pos2.y, zZoom * (float)pos2.z);
  }
  
  void renderLinks(PhysicalModel mdl, int r, int g, int b){
    stroke(255, 255, 0);
    strokeWeight(2);
    for( int i = 0; i < (mdl.getNumberOfLinks()); i++){
      switch (mdl.getLinkTypeAt(i)){
        case Spring3D:
          stroke(0, 255, 0);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break;
        case SpringDamper1D:
          stroke(r, g, b);
aaaaaaaaa
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break;
        case Damper3D:
          stroke(125, 125, 125);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break; 
        case SpringDamper3D:
          stroke(100+10*zZoom*(float)mdl.getLinkPos1At(i).z,0, 255);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break;
        case Rope3D:
          stroke(210, 235, 110);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break;
        case Contact3D:
          break; 
        case PlaneContact3D:
          break;
        case UNDEFINED:
          break;
      }
    }
  }


  void renderModelShapes(PhysicalModel mdl) {
    PVector v;
    synchronized(lock) { 
      for ( int i = 0; i < mdl.getNumberOfMats(); i++) {
        v = mdl.getMatPosAt(i).toPVector().mult(100.);
        massShapes.get(i).moveTo(v.x, v.y, v.z);
      }
  
  
      for ( int i = 0; i < mdl.getNumberOfLinks(); i++) {
        switch (mdl.getLinkTypeAt(i)) {
        case Spring3D:
          stroke(0, 255, 0);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break;
        case Damper3D:
          stroke(125, 125, 125);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break; 
        case SpringDamper3D:
          stroke(0, 0, 255);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break;
        case Rope3D:
          stroke(210, 235, 110);
          drawLine(mdl.getLinkPos1At(i), mdl.getLinkPos2At(i));
          break;
        case Contact3D:
          break; 
        case PlaneContact3D:
          break;
        case UNDEFINED:
          break;
        }
      }
    }
    for (Ellipsoid massShape : massShapes)
      massShape.draw();
  }
}
